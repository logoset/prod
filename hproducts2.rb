# encoding: UTF-8

# ------------------------------------------------------------------------------
#  ЭТОТ БЛОК КОДА НУЖЕН, чтобы переменные в методах puts, p, inspect
# выводились на экран в правильной русской кодировке
# найдено в интернете
if (Gem.win_platform?)
  Encoding.default_external = Encoding.find(Encoding.locale_charmap)
  Encoding.default_internal = __ENCODING__

  [STDIN, STDOUT].each do |io|
    io.set_encoding(Encoding.default_external, Encoding.default_internal)
  end
end
# ------------------------------------------------------------------------------

#
# Таблица-продуктов
# ╔═════════╤══════╤══════════╗
# ║ Артикул │ цена │ описание ║
# ╠═════════╪══════╪══════════╣
# ║         │      │          ║
# ╚═════════╧══════╧══════════╝
# Array
# ┌─┐     Hash
# │0│->{"Артикул": "S123-4","Цена": 300,"Описание": "Смартфон"}
# ├─┤     Hash
# │1│->{"Артикул": "S450-8","Цена": 5100,"Описание": "Балалайка"}
# ├─┤
# │2│
# ├─┤
# │3│
#
# [{"Артикул": "S123-4","Цена": 300,"Описание": "Смартфон"},{"Артикул": "S450-8","Цена": 5100,"Описание": "Балалайка"},{..}...]
#
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Класс Products для работы с массивом товаров @products
# В нем находятся методы, которые взаимодействуют с массивом товаров @products
# Они добавляют, удаляют, изменяют и отображают информацию на экране
# Из методов взаимодействия с пользователем есть только один метод msg_enter
# Остальные методы, требующие взаимодействия с пользователем или принятия
# какого-либо решения вынесеены в отдельные методы основной программы
# ------------------------------------------------------------------------------
class Products
  attr_reader  :hpattern # геттер для доступа к шаблону hpattern из основной программы

  def initialize
    # Создаем пустой одномерный массив для хранения продуктов
    @products=Array.new
    # Шаблон для создания hash-массива, для доступа к названиям ключей и их количеству
    # В качестве значений - формат вывода поля на экран в одной строке,
    # эти значения нужны при выводе списка товаров на экран
    # Если значение = nil, то данное поле не выводится на экран при выводе списка товаров
    #@hpattern={"Артикул"=> "%-10s","Цена"=> "%-10s","Описание"=> "%-30s","Кол-во"=> nil,"Наличие"=> nil}
    @hpattern={"Артикул": "%-10s","Цена": "%-10s","Описание": "%-30s","Кол-во": nil,"Наличие": nil}
  end

  # метод добавляющий тестовые значения товаров в @products
  def  add_test_values
    # если в hash-массиве шаблонов @hpattern ключевые поля типа String,
    # то заносим тестовую инфу , как String в ключевом поле
    # иначе в @hpattrn ключевые поля имеют тип Symbol , потому заносим тестовые значения
    # с ключевыми полями, как Symbol
    if @hpattern.keys[0].class == "54eRS20016".class then
      @products << {"Артикул"=>"S123-4","Цена"=>"300","Описание"=>"Смартфон"}
      @products << {"Артикул"=>"S450-8","Цена"=>"5100","Описание"=>"Балалайка"}
      @products << {"Артикул"=>"S890-12","Цена"=>"12456100","Описание"=>"Лимузин"}
    else
      @products << {"Артикул": "S123-4","Цена": "300","Описание": "Смартфон"}
      @products << {"Артикул": "S450-8","Цена": "5100","Описание": "Балалайка"}
      @products << {"Артикул": "S890-12","Цена": "12456100","Описание": "Лимузин"}
    end
    puts "-"*49
    puts "Тестовые значения добавлены успешно"
    # вызов метода list иэ этого же класса Products, отображающим список товаров
    list
  end

  # метод добавляет в @products значения нового товара, как массив b
  def add_by_array(b)
    @products.push(b)
    puts "Добавлен товар с полями #{b} в ввиде массива"
    # вызов метода list иэ этого же класса Products, отображающим список товаров
    list
  end

  # удаление из @products товара с порядковым номеров id
  def delete_by_id(id)
    # Если значение с индексом id существует в массиве @products, т.е. не равно nil
    if @products[id]!=nil then
      puts "Удален товар #{@products[id]} с порядковым номером #{id+1}"
      @products.delete_at(id)
      # вызываем метод этого класса list, отображающим список товаров
      list
    else
      puts "!!!Удаляемый элемент в массиве товаров c номером #{id} не найден!!!"
      # ждем нажатия ENTER
      msg_enter
    end
  end

  # метод изменяет в @products товар с порядковым номером id на значения массива b
  def change_index_by_array(id,b)
    # если в массиве "b" пустые значения элементов "" или nil, то не изменяем их
    # для этого "старые" значения берем в @products[id][key] и сохраняем в b[key]
    b.each do |key,val|
      b[key]=@products[id][key] if (val==""||val==nil)
    end
    if @products[id]!=nil then
      puts "Товару с номером #{id+1}"
      puts "изменили поля #{@products[id]} на #{b}"
      @products[id]=b
      # вызываем метод этого класса list, отображающим список товаров
      list
    else
      puts "!!!Изменяемый элемент в массиве товаров c номером #{id} не найден!!!"
      # ждем нажатия ENTER
      msg_enter
    end
  end

  # метод поиска товаров в @products и записью найденных значений во временный массив searcharray,
  # который затем возвращается этим же методом, как значение. Для отображения
  # найденных данных используется метод list,   # найденные значения передаются ему,
  # как параметр list(searcharray)
  # Минус подхода поиска через временный массив заключается в том,
  # что нарушается индексация по порядковому номеру.
  # Во временный массив информация кладется со своей нумерацией,
  # которая уже не соответствует той, чтоы была в @products
  # Зато в этом методе нет необходимаости печатать повторно список найденного,
  # а достаточно передать временный массив томй методу,
  # что отображает список. Еще есть идея передавать не массив значений,
  # а массив c найденными id,
  # а в методе list() вытаскивать по этим id значения и отображать
  def search_to_array(txt)
    puts "...осуществляем поиск по фразе: #{txt} "
    # временный массив, куда будут сложены результаты поиска - hash массивы с полями товаров
    searcharray=Array.new
    if @products.length >0 then
      # последоваательно перебераем весь массив @products по елементам item с их индексным номером index
      @products.each_with_index do |item,index|
        # последовательно преобразуем, как в матрешке, Hash в Array(массив значений values)
        # а затем его в строку, в которой ищем подстроку через метод include?
        # если подстрока есть, то печатаем значения
        if (item.values.join.upcase.include? txt.upcase) then
          # "заталкиваем" hash-массивы с данными о товаре во временный массив searcharray
          searcharray.push(item)
        end
      end
      # просим отобразить массив searcharray с найденными значеними с помощью метода list
      list(searcharray)
      # возвращаем массив найденных значений
      return *searcharray
    else
      # печатаем сообщения о том, что поиска не было и почему
      puts "НИЧЕГО НЕ НАЙДЕНО!".center(79)
      puts "ТОВАРОВ НЕТ!".center(79)
      msg_enter
      # возвращаем пустой массив
      return *searcharray
    end
  end

  # метод, который выводит на экран строка за строкой все поля товара
  # по его порядковому номеру val из массива @products или из переданного массива поиска товаров "a"
  def list_info_item(val,a)
    # переданное число преобразуем в целое значение
    val=val.to_i
    # если существует товар с таким индексом в массиве товаров "a"
    if (a[val-1]!=nil) then
      # печатаем заголовок
      puts
      puts "ПОЛНАЯ ИНФОРМАЦИЯ О ТОВАРЕ [№ #{val}]"
      puts "-"*32
      # в keys_format_size - размер самого длинного названия ключа в массиве шаблонов @hpattern,
      # оно будет нужно, чтобы при печати выровнять ширину колонки названий
      keys_format_size=@hpattern.keys.max_by{|x| x.length}.length
      # для каждой пары значений товара с индексным номером val+1 из массива "a"
      # печатаем с форматом в одной строке пару значений key и value из подмассива типа Hash,
      a[val-1].each {|key,value| puts "%-#{keys_format_size}s: %s" % [key,value]}
      # ждем нажатия ENTER
      msg_enter
    else
      # печать сообщения, если товара не существует с индексом val в массиве "a"
      puts "Товара с номером #{val} в списке нет!!!"
      # ждем нажатия ENTER
      msg_enter
    end
  end

  # метод выводит список товаров, которые есть в @products
  def list(*args)
    # Если есть переданные аргументы, то выводим списвок товаров из переданного массива
    # если есть аргумент, то это значит, что метод list вызыван из метода поиска товаров search_to_array
    # в этом случае отображаем список товаров, являющийся результатом поиска,
    # а следовательно все надписив списке будут другие, см. ниже переменные str_header и str_empty
    #
    if args[0] !=nil then
      listarray=args[0]
      str_header="СПИСОК НАЙДЕННЫХ ТОВАРОВ".center(79)
      str_empty="НИЧЕГО НЕ НАЙДЕНО".center(79)
    else
      # иначе будем выводить из массива @products, т.е. по умаолчанию
      listarray=@products
      str_header="СПИСОК ТОВАРОВ".center(79)
      str_empty="ТОВАРОВ НЕТ! ОТОБРАЖАТЬ НЕЧЕГО!".center(79)
    end
    # если массив пустой, то ничего не отображаем, кроме сообщения об этом факте (см. ниже ветку else)
    if listarray.length >0 then
      # печатаем заголовок операции вывода списка на экран
      puts str_header
      # рисуем верхнюю линию таблицы списка
      puts "-"*79
      # печатаем заголовок списка,
      # первое значение - это порядковый номер,точнее его загловок
      print "%-4s" % "№"
      # названия колонок и ширину колонок для формата берем из массива-шаблона @hpattern
      # для каждой пары из @hpattern
      @hpattern.each do |key,value|
        # печатаем , где value определяет формат, key название колонки
        print "#{value}" % "#{key}" if value!=nil
      end
      puts
      # рисуем нижнюю линию заголовка таблицы вывода списка
      puts "-"*79

      # печатаем строка за строкой значения всех полей у всех товаров
      # проходим перебором массив products, где берем пару элемент массива и его индекс
      listarray.each_with_index do |item,index|
        #  печатаем сначала индекс с форматированием 4 знака, выравнивание слева
        print "%-4s" % "#{index+1}"
        # теперь для каждого элемента hash-массива item, который является элементом массива products
        item.each do |key,value|
          #  берем пару ключ и значение, и печатаем их c форматированием
          # в hpattern в ключевом поле лежат названия полей товара и в поле значений формат вывода на печать
          # из него мы извлекаем значение - сколько символов на строку при формате @hpattern[key]
          print "#{@hpattern[key]}" % "#{value}" if @hpattern[key]!=nil
        end
        puts
      end
      # рисуем нижнюю линию таблицы вывода списка
      puts "-"*79
      # возвращаем истину, если отобразили
      return true
    else
      # рисуем линию вверху
      puts "-"*79
      # выводим сообщение о том, почему не отобразили список
      puts str_empty
      # рисуем линию снизу
      puts "-"*79
      # ждем нажатия ENTER
      msg_enter
      # возвращаем ложь, если отображать нечего
      return false
    end
  end

  # метод, который выводит сообщение и ждет нажатия клавиши ENTER
  def msg_enter
    puts
    puts "Для продолжения нажмите клавишу ENTER"
    gets
  end
end

# ------------------------------------------------------------------------------
#                     МЕТОДЫ ОСНОВНОЙ ПРОГРАММЫ
# ------------------------------------------------------------------------------
#   Сюда внесены все методы, которые взаимодействуют с пользователем, где
#                 требуется принятие какого-либо решения,
#              ввода с клавиатуры или отображения информации
# ------------------------------------------------------------------------------

# метод очистки экрана, в зависимости от операционной системы,
# если win, то системный вызов system с командой cls
# иначе это OS unix и тогда нужен системный вызов system с командой clear
def clear
 if (Gem.win_platform?) then
  system('cls')
 else
  system('clear')
 end
end

# метод добавления нового товара, где t - экземпляр класса Products
def add(t)
  input=Hash.new
  puts "ДОБАВЛЕНИЕ НОВОГО ТОВАРА, введите следующие поля:"
  t.hpattern.each_key do |key|
    puts "#{key}:"
    print ">"
    input[key]=gets.chomp
  end
  t.add_by_array(input)
end

# метод удаления товара, где t - экземпляр класса Products
def del(t)
  puts "УДАЛЕНИЕ ТОВАРА"
  # если метод t.list вернул true, то список отобразился, значит есть, что удалять
  # хотя можно проверять не выводом списка, а проверять массив @products на размер
  # но для этого нужно сделать одноименный геттер через attr_reader или attr_accessor
  # в классе Products
  if t.list then
    puts 'Найдите в списке товар, который необходимо УДАЛИТЬ:'
    print "Введите номер>"
    input=gets.chomp.to_i
    # если input не число, то метод to_i вернет 0
    # т.к. у нас выввод порядковогономера в списке товаров
    # на экране начинается с 1, то у нас значение input
    # заведомо должно быть >0
    if input > 0 then
      t.delete_by_id(input-1)
    else
      puts "#{input} -> Порядковый номер должен быть целым числом >0!!!"
      t.msg_enter
    end
  else
    puts "НЕТ ТОВАРОВ ДОСТУПНЫХ ДЛЯ УДАЛЕНИЯ"
  end
end

# метод изменения товара, где t - экземпляр класса Products
def change(t)
  puts "ИЗМЕНЕНИЕ ТОВАРА"
  # если метод t.list вернул true, то список отобразился, значит есть, что удалять
  # хотя можно проверять не выводом списка, а проверять массив @products на размер
  # но для этого нужно сделать одноименный геттер через attr_reader или attr_accessor
  # в классе Products
  if t.list then
    puts "Найдите в списке товар, который необходимо ИЗМЕНИТЬ"
    print "Введите номер>"
    input=gets.chomp.to_i
    if input > 0 then
      puts "Теперь введите НОВЫЕ ЗНАЧЕНИЯ:"
      puts "(если значение пустое, то оно не изменится)"
      puts
      vinput=Hash.new
      t.hpattern.each_key do |key|
        puts "#{key}:"
        print ">"
        vinput[key]=gets.chomp
      end
      t.change_index_by_array(input-1,vinput)
    else
      puts "#{input} -> Порядковый номер должен быть целым числом >0!!!"
      t.msg_enter
    end
  else
    puts "НЕТ ТОВАРОВ ДОСТУПНЫХ ДЛЯ ИЗМЕНЕНИЯ"
  end
end

# передается 1 или 2 аргумента: args[0]-объект класса Products или args[1]-строка поиска
def search(*args)
  t=args[0]
  # Если второй параметр вызова метода не существует, то запрашиваем строку поиска с клавиатуры
  if (args[1] == nil)
    puts "Введите фразу для поиска товара"
    print ">"
    # запрашиваем в переменную input
    input=gets.chomp
  else
    # иначе забираем ее из второго аргумента метода
    input=args[1]
  end
  # вызываем метод поиска в списке товаров по ключевому слову
  # метод возвращает массив найденных значений
  sresult=t.search_to_array(input)
  # если что-то нашли и размер массива >0 то
  if sresult.length>0 then
    # Если в массиве шаблона @hpattern, есть поля, которые не отображаются
    # при выводе списка товаров на экран, т.е. есть значения с параметром nil,
    #  то предложить показать всю информацию из всех полей товара
    if t.hpattern.values.include? nil then
      # запрос на подробные характеристики товара их списка
      puts "В списке показана не вся информация о товарах!"
      puts "Введите номер товара, если хотите увидеть ВСЕ его ХАРАКТЕРИСТИКИ"
      print ">"
      # запрос значения с клавиатуры
      input=gets.chomp
      #  если ввели не пустое строковое значение, то
      # если это номер и он > 0, то введен индекс товара
      if input.to_i >0 then
        # вызвать метод этого класса list_info_item для показа значений из всех полей товара
        t.list_info_item(input,sresult)
      end
    else
      # иначе просто вывести сообзщение,
      # ждем нажатия ENTER
      t.msg_enter
    end
  end
end

def list(t)
  # вызываем метод отображения списка товаров и проверяем, отобразилось что-то им или нет
  # метод list возвращает true, если что-то отобразилось,false, если нет
  if t.list then
    # запрос на подробные характеристики товара из списка
    puts "Отфильтровать список по фразе в полях товара?"
    puts "Введите запрос или просто ENTER, чтобы продолжить"
    print "запрос>"
    # запрос значения с клавиатуры
    input=gets.chomp
    if (input !="") && (input != nil) then
      # вызываем метод этого класса list_by_search поиска товаров по фразе
      search(t,input)
    end
  end
end

# ------------------------------------------------------------------------------
#                       Основная программа
# ------------------------------------------------------------------------------

# Создаем объект товара tovar на основе класса Products
tovar=Products.new
# exitval - переменная флаг, в которой хранится истина или ложь
exitval=false
# флаг перерисовки меню
choisen=true
# пока в переменной exitval ложь, будет выполняться вечный цикл
# программа выйдет из вечного цикла, когда мы присвоим переменной exitval значение true
while (exitval==false)

  # На экран печатем меню, для взаимодейсствия с пользователем
  # если до этого был выбор - определем по переменной-флагу choisen, то рисчуем меню
  # если нет, то оно уже выведено и перерисовывать его не нужно
  if choisen==true then
    puts "-"*49
    puts "МЕНЮ - выберете первую букву меню и нажмите ENTER"
    puts "-"*49
    puts "(L) Список товаров"
    puts "(T) Добавить тестовые значения товара"
    puts "(A) Добавить товар"
    puts "(D) Удалить товар"
    puts "(С) Изменить товар"
    puts "(F) Поиск товара"
    puts "(Q) Выход из программы"
  end
  # ожидаем ввода значения с клавиатуры и сохраняем его в переменной choice
  choice=gets.chomp

  # переменная choice приводится к верхнему регистру, методом upcase.
  # в зависимости от значения choice
  # отрабатывается соответсвующая ветка операторв case->when
  case choice.upcase
    when "L","Д","д"
      clear
			choisen=true
			list(tovar)
    when "A","Ф","ф"
      clear
			choisen=true
			add(tovar)
    when "D","В","в"
      clear
			choisen=true
			del(tovar)
    when "C","С","с"
      clear
			choisen=true
			change(tovar)
    when "T","Е","е"
      clear
			choisen=true
			tovar.add_test_values
    when "F","А","а","S","Ы","ы"
      choisen=true
			search(tovar)
    when "Q","Й","й"
      # если нажата q , то выходим из вечного цикла и завершаем программу
      choisen=true
			exitval=true
    else
      choisen=false
  end
end
