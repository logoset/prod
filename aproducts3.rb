# encoding: UTF-8
# ------------------------------------------------------------------------------
# этот блок кода нужен, чтобы переменные в методах puts, p, inspect
# выводились на экран в правильной русской кодировке
# найдено в интернете
if (Gem.win_platform?)
  Encoding.default_external = Encoding.find(Encoding.locale_charmap)
  Encoding.default_internal = __ENCODING__

  [STDIN, STDOUT].each do |io|
    io.set_encoding(Encoding.default_external, Encoding.default_internal)
  end
end
# ------------------------------------------------------------------------------
#
# Таблица-массив продуктов
# ╔═════════╤══════╤══════════╗
# ║ Артикул │ цена │ описание ║
# ╠═════════╪══════╪══════════╣
# ║         │      │          ║
# ╚═════════╧══════╧══════════╝
# [[articul1,price1,comment1],[article2,price2,comment3],[]...]


# Глобавльная переменная $products_array_pattern нужна для того, чтобы определить количество столбцов,
# а соответственно и параметров, которые нужно обрабатывать методам (заготовка на будущую универсальность)
#




$products_array_pattern={vendorcode: "",price: 0, description: ""}

# Инициализируем массив продуктов
aproducts=[]
# Добавим начальные значения
#aproducts=[["AS23-GH-12",123,"Baton"],["AS23GH12",50,"Steel"]]

# Класс для работы с массивом товаров
class Products
  # Добавляем товар по значению - три поля val1, val2, val3 -значения, а - массив с товарами
  def add_by_values(val1,val2,val3,a)
      b=[val1,val2,val3]
      a.push(b)
      puts "Добавлен товар с полями #{val1}, #{val2}, #{val3}"
  end

  # тоже, только первый переданный методу параметр-одномерный массив b, который содержит значения товара
  # вставляем его в массив всех товаров a
  def add_by_array(b,a)
     # вызываем метод класса Array push, добавляется новое значение в в конце массива a
      a.push(b)
      puts "Добавлен товар с полями #{b} в ввиде массива"
  end
  # удавлем товар по id,  параметры id - индекс массива с товарами а, который надо удалить
  def delete_by_id(id,a)
      puts "Удален товар #{a[id]} с порядковым номером #{id}"
      a.delete_at(id)
  end

  # Удалть товар с поиском по тексту text среди элементов массива всех товаров a
  def delete_by_text(text,a)
    # цикл по всем элементам массива товаров a;
    #  в каждой итерации циклического пербора значений item принимает значение одного из товаров
    #  item - тоже массив, только в нем значения одного товара
    a.each do |item|
      # если в подмассиве item[] среди его элеменов есть текст item.include?(text) ,
      # то вызывается метод удаления по условию delete_if
      # в общем, в этой конструкции сначала отрабатывет условие справа if, потом уже,
      # если условие выполняется, то то, что слева от него delete_if
      a.delete_if {|x| x==item} if item.include?(text)
    end

  end

  # Удаляем элемент из массива товаров a, вызывая метод удаления элемента по условию delete_if,
  # где эталон для поиска удяляемого индекса является готовый подмоассив значений b
  def delete_by_array(b,a)
    puts "Удаляем товары со значениями полей #{b}"
    a.delete_if do |item|
      item==b
    end
  end

  # Удаление по значению
  # тоже, что удаление по массиву, только массив для поиска формируется из переданных значений value1,value2,value3
  def delete_by_values(value1,value2,value3,a)
    puts "Удаляем товар со значениями полей #{value1}, #{value3}, #{value3}"
    a.delete_if{|item| item==[value1,value2,value3]}
  end

  # несколько методов изменения массива, в зависимости от аргументов

  # изменяем значение - аргументы передаются в виде сслыки на массив args их может быть разное количество
  def change_by_valuesarrays(*args)
    # если их 7 , то значит для изменения запрашиаются все параметры одного из товаров типа args[0],args[1],args[2]
    # а три последующих [args[3],args[4],args[5] - это то, на что надо изменить
    # массив товаров, где надо менять значение идет последним в списке параметров
    if args.size == 7 then
      a=args[6]
      # проверяем, что индекс для значений товара существует и не равен nil
      if a.index([args[0],args[1],args[2]]) !=nil then
        puts "Замена товара с полями #{args[0]},#{args[1]},#{args[2]} на #{args[3]},#{args[4]},#{args[5]}"
        # изменяем значение , расположенное по индексу a.index(args[0],args[1],args[2]) новыми значениями args[3],args[4],args[5]
        # новые значения заключаем в скобки [args[3],args[4],args[5]]
        a[a.index([args[0],args[1],args[2]])]=[args[3],args[4],args[5]]
      else
          # если не нашли значение в массиве товаров, то сообщаем об этом
          puts "!!!Изменяемый элемент со значениями полей #{args[0]},#{args[1]},#{args[2]} не найден!!!"
      end
    end
    # если их 3, то значит первые два параметра переданы как массивы
    # тут все тоже самое, только a.index(args[0]) получает не набор значений, а массив
    if args.size == 3 then
      # в переменную a передаем массив всех товаров, он передался в параметрах в третьей позиции args[2]
      a=args[2]
      if a.index(args[0])!=nil then
        puts "Замена товара с переданными массивами значений #{args[0]} и #{args[1]}"
        a[a.index(args[0])]=args[1] # новые значения тоже из второго массива args[1]
      else
        # если не нашли значение в массиве товаров, то сообщаем об этом
        puts "!!!Изменяемый элемент со значением #{args[0]} не найден!!!"
      end
    end
  end

  # значение товара в массиве товаров a, ищется по его значениям a1,a2,a3 и заменяется на значения b1,b2,b3
  def change_by_values(a1,a2,a3,b1,b2,b3,a)
    # если существует индекс в массиве товаров a, с такими значениями товара a1,a2,a3
    if a.index(args[0])!=nil then
      # то делаем замену, новые значения формируем , как массив, заключая в скобки [b1,b2,b3]
      puts "Замена товара с полями в виде значений с #{a1},#{a2},#{a3} на #{b1},#{b2},#{b3}"
      a[a.index([a1,a2,a3])]=[b1,b2,b3]
    else
        # если не нашли значение в массиве товаров, то сообщаем об этом
        puts "!!!Изменяемый элемент со значением #{a1},#{a2},#{a3} не найден!!!"
      end
  end
  # изменяем значение по id, но новые значения переданы, как отдельные значения
  def change_index_by_values(id,b1,b2,b3,a)
    # проверяем, что такой элемент, с индексом id в массиве товаров существует, и не равен nil
    if a[id]!=nil then
      puts "Товару с порядковым номером #{id} заменили поля на #{b1},#{b2},#{b3}"
      # справа формируем массив из трех значений, которые переданы , как параметры и присваеваем значению с индексом id в массиве товаров a
      a[id]=[b1,b2,b3]
    else
      # если не нашли значение в массиве товаров, то сообщаем об этом
      puts "!!!Изменяемый элемент c номером #{id} не найден!!!"
    end
  end

  # изменяем старое значение, которое находится под идтексом id, на новое b, где b мвссив значений
  def change_index_by_array(id,b,a)
    # проверяем, что такой элемент, с индексом id в массиве товаров существует, и не равен nil
    if a[id]!=nil then
      puts "Товару с порядковым номером #{id} заменили поля значениями из массива #{b}"
      a[id]=b
    else
      # если не нашли значение в массиве товаров, то сообщаем об этом
      puts "Изменяемый элемент номером #{id} не найден!!!"
    end
  end

  # список всех товаров, который надо вывести на экране
  def list(a)
    puts "СПИСОК ТОВАРОВ"
    puts("%-25s %-25s %-25s" % ["Артикул", "Цена","Описание"])
    puts "-"*79
    a.each {|item| puts  ("%-25s %-25s %-25s" % [item[0],item[1],item[2]])}
    puts "-"*79 # Напечатать символ - подряд 79 раз в одной строке
  end

  # список всех товаров , который надо вывести на экране, но с порядковым номером
  def list_with_index(a)
    puts "СПИСОК ТОВАРОВ"
    # выставляем счетчик в 1. Этим счетчиком будем отслеживать в цикле перебора элементов массива номера этих элементов
    i=1
    # печатаем заголовок
    # строку форматируем: %-числоs 30символов для строк, перечисленных в массиве
    puts("%-4s %-20s %-20s %-25s" % ["Индекс","Артикул", "Цена","Описание"])
    puts "-"*79
    # Проходим по всему массиву товаров a
    a.each do |item|
      # и распечатываем индекс элемента и с форматированием значения элеметов item каждого товара
      puts  ("%-4s %-20s %-20s %-25s" % [i,item[0],item[1],item[2]])
      # увеличиваем счетчик на 1
      i=i+1
    end
    puts "-"*79
  end
end

# ------------------------------------------------------------------------------
# Методы основной программы
# ------------------------------------------------------------------------------

# Очистка экрана(функция взята из инетрнета - анализируется переменная RUBY_PLATFORM
# Если в ней встречаются строки win32,win64,windows и т.д., то делается системный вызов cls
# иначе для unix)
def clearscreen
   puts "amit"
   if RUBY_PLATFORM =~ /win32|win64|\.NET|windows|cygwin|mingw32/i
      system('cls')
    else
      system('clear')
   end
end

# метод запрооса значений в переменную input
def input_array_values
  input=Array.new
  puts 'Введите Артикул(уникальный номер) товара:'
  print ">"
  # символ << одна из форм добаления в конец массива inp значения
  # все, что мы ввели на экран, возвращается функцией gets и заносится в массив inp
  input<<gets.chomp
  puts 'Введите цену товара:'
  print ">"
  input<<gets.chomp
  puts 'Введите описание товара:'
  print ">"
  input<<gets.chomp
  # метод возвращает массив input
  return input
end

# метод, который предлагает два варианта ввода значений
# 1) через точку запятой в одну строчку
# 2) последовательно ввести каждое значение
# методом возвращается массив значений или false, если отказались вводить значения, т.е нажали Q
def input_array_values_by_choice
  # Печатаем меню вариантов ввода товара
  puts '      Выберите один из вариантов меню ввода параметров товара:'
  puts '(1) Ввести все параметры товара одной строкой(значения разделены ";")'
  puts '(2) Ввести каждый параметр по отдельности'
  puts '(Q) Выйти'
  # запрашиваем с клавиатуры ввод методом gets и проверяем введенное значение в операторе case
  case gets.chomp.upcase
    when "1"
      puts 'Введите Артикул, Цену и Описание товара одной строкой, разделив их символом ";"'
      puts 'Например:   Артикул       Цена Описание'
      puts '            23SE45DFN5-15;2500;Смартфон'
      print ">"
      # заправшиваем с клавиатуры все значения в одну строку и разделяем ее в элементы массива,
      # котрый сохраняется в переменной input
      input=gets.chomp.split(";")
      # выходим из метода, возвращая тому, кто его вызывал массив input
      return input
    when "2"
      # Вызываем наш метод input_array_values последовательного ввода значений товара,
      # который возвращается в виде массива и присваивается переменной input
      input=input_array_values
      # выходим из метода, возвращая тому, кто его вызывал массив input
      return input
    when "Q","Й","й"
      # если отказались вводить значения, нажав Q, то возвращаем false
      return false
  end
end

def add_test(t,a)
    # добавлю несколько значений программно
  # Пример, как вызывать добавление товара, где параметры не массив товара inp,
  # а все значения товара передаются в качестве параметра метода по отдельности
  t.add_by_values("1445DFN5-15","8400", "Смартфон кнопочный",a)
  t.add_by_values("23SE45D-FN5-15","300", "Кошелек",a)
  t.add_by_values("23SE45DFN5-15","2500", "Смартфон",a)
  t.add_by_values("AS23-GH-12","123","Baton",a)
  t.add_by_values("as2","5","s",a)

end

# Метод add - добавление одного товара в массив продуктов, вызывается из меню
# Сначала запрашивается у пользователя ввести необходимые значения для товара:
# артикул, цена, описание.
# Чтобы работать внутри метода с внешними объектами, они передаются в метод, как параметры
# t -это объект tovary(класс Products), а - массив со значениями товаров aproducts
def add(t,a)


  # Вызываем наш метод, который предлагает 2 варианта ввода значений
  # 1) в одну строку, через запятую
  # 2) запрашивая последовательно каждое значение
  # результат возвращается в переменну. inp
  inp=input_array_values_by_choice
  # если наш метод вернул false, то значений в массиве inp нет, есть не false, то там есть значения
  if inp then
    # вызываем метод add_by_array объекта tovar, которому передаем введенный массив inp и масстив товаров a
    t.add_by_array(inp,a)
    #вывод на экран всех товаров в массиве a. Вызывается метод list объекта tovar
    t.list(a)
  else
    puts "Значения для нового товара не введены"
    puts 'нажмите ENETER'
    gets
  end
end

# Метод  вывода на экран списка всех товаров, вызанный из меню
def list(t,a)
  # очищаем экран
  clearscreen
  # вызываеи метод list параметром которого служит массив с товарами
  t.list(a)
end

# Метод удаления товара, вызывается из меню.
# Разные способы удаления
# P - по значениям твоарв
# N - по индексу в массиве товарв
# В параметрах t - это объект товаров
# a - массив товаров
def del(t,a)
  # Печатаем меню способов удаления товара
  puts "Какой товар следует УДАЛИТЬ?"
  puts "(P) Указать все параметры товара, по которым он будет удален"
  puts "(N) Указать индексный номеру товара"
  puts "(Q) Ничего не делать и вернуться назад"
  # ждем выбора пользователя
  # gets - метод ожидания ввода с клавиатуры, chomp - метод удаления управляющих символов в веденой строке, upcase - метод перевода в верхний регистр
  # и проверяем , что нажали на клаватуре
  inp=gets.chomp.upcase
  # Если нажато P или в русской раскладке "З","з"
  if  inp=="P"||inp=="З" || inp=="з" then
    # информируем, как вводить значения
    puts 'Найдите в списке товар, который необходимо удалить:'
    # показываем список товаров в массиве a
    t.list(a)
    # Вызываем метод ввода значений иовара в одну строку или по отдельности
    # результата - массива, присваивается переменной inp
    inp=input_array_values_by_choice
    # если значения введены, то
    if inp then
      # вызываем метод удаления значения delete_by_array, где параметром служит массив значений товара inp
      t.delete_by_array(inp,a)
      # ожидаем нажатия клавиатуры
      puts "для продолжения нажмите ENTER"
      gets
      # очищаем экран
      clearscreen
      # выводим список всех товаров на экран, проверяем
      t.list(a)
    else
      puts "Значения удаляемого товара не введены"
      puts 'нажмите ENETER'
      gets
    end
  end
  # Если нажата клавиша N (или "Т","т" в русской раскладке), то будем удалять по индексу
  if inp=="N"||inp=="Т"||inp=="т" then
    # оповещаем, что надо делать
    puts 'Просмотрите список всех товаров и введите индексный номер требуемой позиции:'
    puts "-"*79
    # метод вывода на икран списка всех товаров с их индекными номерами id в массиве a
    t.list_with_index(a)
    # ждем ввода значения от пользователя и конвертируем его в целочисленное значение
    puts "Введите порядковый номер товара, который нужно удалить:"
    print ">"
    # Запрашиваем значение с клавиатуры и сохраняем в строковой переменной inp
    inp=gets.chomp
    # проверяем преобразование строковой переменной inp в целочисленное значение
    # если это не число, то метод to_i вернет значение 0, ну а так, как мы выводили список, начиная с 1
    # то по любому у нас не может быть 0
    if inp.to_i then
      # вызываем метод объекта tovar delete_by_id , где параметром служит индекс,
      # который мы запросили в методе gets.chomp-1 и массив товаров "a"
      # -1 это потому, что при выводе списка товаров, индекс указан, начиная с 1, а у массивов индексация начинается с 0
      # это надо учитывать
      t.delete_by_id(inp.to_i-1,a)
      puts "для продолжения нажмите ENTER"
      gets
      # очищаем экран
      clearscreen
      # выводим список всех товаров на экран, проверяем
      t.list_with_index(a)
    else
        # печатаем сообщение об ошибке, когда введены не цифры, когда inp.to_i вернул 0
        puts "!!!Вы ввели НЕ ЧИСЛОВОЕ ЗНАЧЕНИЕ порядкового номера товара!!!"
    end
  end
end

# Изменение значения товара t в списке всеех товаров масcива a
# В качестве переданных параметров объект tovar и массив aproducts
def change(t,a)
  # печатаем меню
  puts "Какой товар следует ИЗМЕНИТЬ?"
  puts "(V) Поиск и изменение товара по всем его параметрам"
  puts "(I) Изменение товара по его порядковому номеру"
  puts "(Q) Ничего не делать и вернуться назад"
  # Ждем ввода с клавиатуры приводим полученное значение к верхнему регистру
  inp=gets.chomp.upcase
  # если inp = V или же в русской раскладке М или м
  if inp=="V"||inp=="М"||inp=="м" then
    puts 'Выберете из списка тот товар,который требуется изменить'
    # для удобства выводим на экран список товаров из масива "a"
    t.list(a)

    # Вызываем метод ввода значений товара в одну строку или по отдельности
    # результата - массива, присваивается переменной inp
    puts "ВВОД СТАРЫХ параметров товара"
    inpm=input_array_values
    puts "-"*79
    puts "ВВОД НОВЫХ параметров товара"
    inpn=input_array_values
    # вызываем метод изменения значений, параметры:
    # inpm- старый массив значений товара,inpn-новый массив занчений товара,a -массив товаров
    t.change_by_valuesarrays(inpm,inpn,a)
    puts "для продолжения нажмите ENTER"
    gets
    # очищаем экран
    clearscreen
    # выводим список всех товаров
    t.list(a)


  end
  # Если нажата клавиша I или , что тоже самое в русской раскладке Ш или ш
  if  inp=="I"||inp=="Ш"||inp=="ш" then
    #  Тут все тоже самое, только запрашивается индекс элемента в списке товаров
    puts 'Просмотрите список всех товаров и введите порядковый номер требуемой позиции:'
    t.list_with_index(a)
    puts "Введите выбранный индекс товара:"
    print ">"
    inp=gets.chomp.to_i
    # проверяем преобразование строковой переменной inp в целочисленное значение
    # если это не число, то метод to_i вернет значение 0, ну а так, как мы выводили на экран список товаров,
    # начиная с 1, то по любому у нас не может быть 0
    if inp.to_i then
      puts 'Введите НОВЫЕ параметры товара, разделив их символом ";"'
      # Вызываем наш метод последовательного ввода в массив занчений товара, результат передается в переменную inpn
      inpn=input_array_values
      # вызываем метод замены значения по индексу в массиве товаров change_index_by_array,
      # где параметром служит индекс inp-1, массив новых значений inpm и массив товаров "a"
      # -1 это потому, что при выводе списка товаров, индекс указан, начиная с 1, а у массивов индексация начинается с 0
      t.change_index_by_array(inp-1,inpn,a)
      puts "для продолжения нажмите ENTER"
      gets
      # печатаем измененный список
      t.list_with_index(a)
    else
        # печатаем сообщение об ошибке, когда введены не цифры, когда inp.to_i вернул 0
        puts "!!!Вы ввели НЕ ЧИСЛОВОЕ ЗНАЧЕНИЕ порядкового номера товара!!!"
    end
  end
end

# ------------------------------------------------------------------------------
#                       Основная программа
# ------------------------------------------------------------------------------

# Создаем объект товара tovar на основе класса Products
tovar=Products.new
# exitval - переменная флаг, в которой хранится истина или ложь
exitval=false
# пока в переменной exitval ложь, будет выполняться вечный цикл
# программа выдет из вечного цикла, когда мы присвоим переменной exitval значение true
while (exitval==false)
  # На экран печатем меню, для взаимодейсствия с пользователем
  puts "Меню - выберете первую букву меню"
  puts "(L) Список товаров"
  puts "(T) Добвать тестовые значения товара"
  puts "(A) Добавить товар"
  puts "(D) Удалить товар"
  puts "(С) Изменить товар"
  puts "(F) Найти товар"
  puts "(Q) Выход из программы"

  # ожидаем ввода значения с клавиатуры и сохраняем его в переменной choice
  choice=gets.chomp

  # В зависимости от нажатой буквы, которая проверяется в операторе case
  # вызывается соответствующий метод
  # если нажата L, то вызываем метод list
  # если нажата A, то вызываем add и т.д.
  # переменная choice приводится к верхнему регистру, методом upcase
  case choice.upcase
    when "L","Д","д"
      list(tovar,aproducts)
    when "A","Ф","ф"
      add(tovar,aproducts)
    when "D","В","в"
      del(tovar,aproducts)
    when "C","С","с"
      change(tovar,aproducts)
    when "T","Е","е"
      add_test(tovar,aproducts)
    when "Q","Й","й"
      # если нажата q , то выходим из вечного цикла и завершаем программу
      exitval=true
  end
end
